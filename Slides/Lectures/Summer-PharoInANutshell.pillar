{
	"title":"Pharo in a Nutshell",
	"subtitle":"",
	"slidesid":"Summer"
}


${slide:title=Outline}$

- Pharo?
- Vision
- Model
- Pharo Syntax

${slide:title=Pharo?}$

+ >file://figures/pharo.png|width=100+

${slide:title=Pharo}$

- System: Pure object language + full IDE
- Powerful, elegant and fun to program
- Living system under your fingers
- Works on Mac OSX, Linux, iOS, Android, Windows, Pi - 100\% MIT
- Great community / industrial consortium


${slide:title=Elegant}$

- Full syntax on a postcard
- Simple and powerful objet model


${slide:title=Pharo}$

Mainly objects, messages and lexical closures


${slide:title=Full syntax on half a postcard}$

+ >file://figures/pharo-fullpostcard.png|width=95+

${slide:title=Zoom on postcard}$

+ >file://figures/pharo-postcard.png|width=50+


${slide:title=Temporary declaration, assignment, separator and return}$

Temporary declaration, assignment, separator, and return

[[[

| a |

a := 40 + 2.

^ a

]]]

${slide:title=Lexical closures: Blocks}$

- closure definition 
[[[
[:x | x + 5]
]]]

- closure execution 

[[[
> [:x | x + 5] value: 37
42
]]]




${slide:title=Messages}$

- Unary messages
[[[
Date today
9 squared
]]]
- “Operators” Binary 
[[[
4 + 3
'Black ', 'Chocolate ', 'is good'
]]]
- Keywords messages
[[[	
2 between: 0 and: 10
2.betweenAnd(0, 10)
]]]


${slide:title=Control flow operators are messages}$

[[[
Weather today isRaining 
   ifTrue: [ self takeUmbrella]
   ifFalse: [ self takeSunglasses]
]]]

Yes we send messages to Boolean objects


${slide:title=Your own DSL}$

You can easily defined your own DSL

[[[
False >> siVrai: aBlock1 faux: aBlock2
	^ aBlock2 value 
]]]


${slide:title=Iterators all the way}$

[[[
> #( 1 -2 -3 4 -5) collect: [:each | each abs]
#( 1 2 3 4 5)
]]]

Yes we send messages to collection to do loops

${slide:title=You can define your own iterator}$

[[[
#(1 2 3) 
	do: [:each | stream print: each ]
	separatedBy: [ stream << ', ']

1, 2, 3
]]]


${slide:title=Class definition}$

[[[
Object << #Point
	slots: { #x . #y };
	package: ‘Kernel'
]]]

${slide:title=Method definition}$

[[[
<= aPoint 
	"Answer whether the receiver is neither below nor to the right of aPoint."
	^ x <= aPoint x and: [y <= aPoint y]
]]]


	
${slide:title=Iterators all the way}$

+ >file://figures/spec-coreExtended.pdf|width=95+

${slide:title=Key concepts}$

+ >file://figures/spec-core.pdf|width=95+


${slide:title=Focus on Presenter part}$

A presenter describes
- its subcomponents
- their configuration 
- their layout 
- communication with domain model


${slide:title=Example}$

Illustrating key API of `SpPresenter`

${slide:title=Example: a simple todo}$

+ >file://figures/spec-TodoDone.png|width=95+



${slide:title=InitializePresenter}$

[[[
TodoListPresenter >> initializePresenters
	todoListPresenter := self newTable
		addColumn: ((SpCheckBoxTableColumn 
			evaluated: [:task | task isDone]) width: 20);
		addColumn: (SpStringTableColumn 
			title: 'Title' evaluated: [:task | task title]);
		yourself.
]]]

${slide:title=defaultLayout}$

[[[Smalltalk
TodoListPresenter >> defaultLayout
	^ (SpBoxLayout newTopToBottom 
		add: todoListPresenter;
		yourself) 
]]]

${slide:title=Update Presenter}$

[[[
TodoListPresenter >> updatePresenter
    todoListPresenter items: TodoTask tasks
]]]

${slide:title=Initialize window}$

[[[
TodoListPresenter >> initializeWindow: aWindowPresenter

    aWindowPresenter 
        title: 'Todo List';
        initialExtent: 500@500
]]]

${slide:title=Connecting presenters}$

When a component is composed of multiple ones you may need to maintain some invariant.

Imagine you have a list of items and an item description text and you want to always show the description of the selected item.

[[[
connectPresenters
    
	itemList whenSelectionChangedDo: [ :each | description text: each text]
]]]


${slide:title=Book}$

The forthcoming book freely available at: 
*https://github.com/SquareBracketAssociates/BuildingApplicationWithSpec2>https://github.com/SquareBracketAssociates/BuildingApplicationWithSpec2*
